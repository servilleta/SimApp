# ðŸ“‹ LOGSTASH PIPELINE - Enterprise Logging
# Phase 5 Week 17-18: Centralized Log Processing
#
# This pipeline processes logs from:
# - Monte Carlo Backend (Ultra Engine)
# - Frontend Application
# - Nginx Access/Error Logs
# - Database Logs
# - Redis Logs

input {
  # Docker container logs
  beats {
    port => 5044
  }
  
  # Direct TCP input for applications
  tcp {
    port => 5000
    codec => json
  }
  
  # HTTP input for webhooks
  http {
    port => 8080
  }
}

filter {
  # Parse Docker container logs
  if [docker][container][name] {
    mutate {
      add_field => { "service" => "%{[docker][container][name]}" }
    }
    
    # Parse Monte Carlo Backend logs
    if [docker][container][name] =~ /backend/ {
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} - %{LOGLEVEL:level} - %{GREEDYDATA:log_message}"
        }
      }
      
      # Extract simulation metrics
      if [log_message] =~ /simulation/ {
        grok {
          match => {
            "log_message" => "Simulation %{WORD:simulation_id} %{WORD:action} in %{NUMBER:duration:float}ms"
          }
        }
        
        mutate {
          add_field => { "metric_type" => "simulation_performance" }
        }
      }
      
      # Extract Ultra Engine performance metrics
      if [log_message] =~ /progress_bar/ {
        grok {
          match => {
            "log_message" => "Progress bar response: %{NUMBER:response_time:float}ms"
          }
        }
        
        mutate {
          add_field => { "metric_type" => "ultra_engine_performance" }
        }
      }
    }
    
    # Parse Nginx access logs
    if [docker][container][name] =~ /nginx/ {
      grok {
        match => {
          "message" => "%{NGINXACCESS}"
        }
      }
      
      # Calculate response time categories
      if [response_time] {
        if [response_time] < 100 {
          mutate { add_field => { "performance_category" => "excellent" } }
        } else if [response_time] < 500 {
          mutate { add_field => { "performance_category" => "good" } }
        } else if [response_time] < 1000 {
          mutate { add_field => { "performance_category" => "acceptable" } }
        } else {
          mutate { add_field => { "performance_category" => "poor" } }
        }
      }
    }
    
    # Parse Frontend logs
    if [docker][container][name] =~ /frontend/ {
      # Parse JavaScript errors and performance metrics
      if [message] =~ /ERROR/ {
        mutate {
          add_field => { "log_type" => "frontend_error" }
        }
      }
      
      if [message] =~ /PERFORMANCE/ {
        grok {
          match => {
            "message" => "PERFORMANCE: %{WORD:metric_name} took %{NUMBER:duration:float}ms"
          }
        }
        
        mutate {
          add_field => { "log_type" => "frontend_performance" }
        }
      }
    }
  }
  
  # Add timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
  }
  
  # Add environment and service tags
  mutate {
    add_field => {
      "environment" => "production"
      "platform" => "monte_carlo_enterprise"
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "agent", "ecs" ]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "monte-carlo-logs-%{+YYYY.MM.dd}"
    template_name => "monte-carlo"
    template_pattern => "monte-carlo-*"
    template => {
      "index_patterns" => ["monte-carlo-*"],
      "settings" => {
        "number_of_shards" => 1,
        "number_of_replicas" => 0
      },
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" },
          "service" => { "type" => "keyword" },
          "level" => { "type" => "keyword" },
          "message" => { "type" => "text" },
          "duration" => { "type" => "float" },
          "response_time" => { "type" => "float" },
          "metric_type" => { "type" => "keyword" },
          "performance_category" => { "type" => "keyword" }
        }
      }
    }
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}

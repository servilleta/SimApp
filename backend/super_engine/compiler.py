"""
SUPERENGINE - AST Compiler / Execution Engine
===========================================
This module contains the AST 'walker' that executes a parsed formula.
It recursively traverses the Abstract Syntax Tree generated by the parser,
and at each node, it dispatches the appropriate GPU kernel from the kernel library.

This is the core of the formula execution engine.
"""

import logging
import cupy as cp
from typing import Dict, Any, Tuple, Union

from super_engine.gpu_kernels import KERNEL_LIBRARY, is_gpu_available
from super_engine.parser import FormulaParser

logger = logging.getLogger(__name__)

class AstCompiler:
    """
    Compiles and executes an AST on the GPU.
    """
    def __init__(self, simulation_data: Dict[str, cp.ndarray], named_ranges: Dict[str, cp.ndarray], iterations: int):
        """
        Initializes the compiler with the necessary simulation data.

        Args:
            simulation_data: A dictionary mapping cell references (e.g., "A1")
                             to CuPy arrays representing the Monte Carlo iterations
                             for that cell.
            named_ranges: A dictionary mapping named ranges to their corresponding
                          CuPy arrays of simulation data.
            iterations: The number of Monte Carlo iterations.
        """
        if not is_gpu_available():
            raise RuntimeError("Cannot initialize AstCompiler: No compatible GPU found.")
        
        self.simulation_data = simulation_data
        self.named_ranges = named_ranges
        self.iterations = iterations
        self.parser = FormulaParser()
        logger.info("✅ SUPERENGINE: AST Compiler initialized.")

    def compile_and_run(self, formula_string: str) -> cp.ndarray:
        """
        Parses, compiles, and runs a formula string.

        Args:
            formula_string: The Excel formula to execute (e.g., "=A1+B1").

        Returns:
            A CuPy array containing the results of the simulation for the formula.
        """
        logger.info(f"Compiling formula: {formula_string}")
        ast = self.parser.parse(formula_string)
        return self._walk_ast(ast)

    def _walk_ast(self, node: Tuple) -> Union[cp.ndarray, float]:
        """
        Recursively walks the AST and executes the corresponding GPU kernels.

        Args:
            node: The current AST node to process.

        Returns:
            The result of the computation for this node.
        """
        node_type = node[0]

        if node_type == 'number':
            # A scalar number
            return node[1]
        
        elif node_type == 'string':
            # A string literal
            return node[1]
        
        elif node_type == 'cell':
            # A reference to a cell's simulation data
            cell_ref = node[1]
            if cell_ref not in self.simulation_data:
                raise ValueError(f"Missing simulation data for cell: {cell_ref}")
            return self.simulation_data[cell_ref]

        elif node_type == 'named_range':
            # A reference to a named range's simulation data
            range_name = node[1]
            if range_name not in self.named_ranges:
                raise ValueError(f"Unknown named range: {range_name}")
            return self.named_ranges[range_name]

        elif node_type == 'range':
            # A reference to a range of cells, needs to be aggregated
            # This part needs a helper to collect data from the range
            start_cell, end_cell = node[1], node[2]
            # In a real scenario, you'd collect all arrays in simulation_data
            # that fall within this range and stack them.
            # Placeholder: just using start cell for demonstration
            logger.warning(f"Range handling for {start_cell}:{end_cell} is a placeholder.")
            return self.simulation_data[start_cell]

        elif node_type in ('add', 'sub', 'mul', 'div', 'gt', 'lt', 'eq', 'gte', 'lte', 'neq'):
            # Binary operation (Arithmetic or Logical)
            left_val = self._walk_ast(node[1])
            right_val = self._walk_ast(node[2])
            kernel = KERNEL_LIBRARY[node_type]
            return kernel(left_val, right_val)

        elif node_type == 'function_call':
            # A function call like SUM, AVERAGE, etc.
            func_name = node[1]
            if func_name not in KERNEL_LIBRARY:
                raise NotImplementedError(f"GPU kernel for function '{func_name}' is not implemented.")
            
            # Evaluate all arguments first
            args = [self._walk_ast(arg) for arg in node[2]]
            
            kernel = KERNEL_LIBRARY[func_name]
            
            # Special handling for IF function
            if func_name == 'IF':
                if len(args) != 3:
                    raise ValueError("IF function requires 3 arguments: condition, value_if_true, value_if_false")
                return kernel(args[0], args[1], args[2])

            if func_name == 'SUMIF':
                if len(args) != 3:
                    raise ValueError("SUMIF function requires 3 arguments: range, criterion, sum_range")
                return kernel(args[0], args[1], args[2])

            if func_name == 'NPV':
                if len(args) < 2:
                    raise ValueError("NPV function requires at least 2 arguments: rate, value1, ...")
                rate = args[0]
                cash_flows = args[1:]
                return kernel(rate, cash_flows)

            # Special handling for functions that take a list of arguments
            if func_name in ('AND', 'OR', 'MIN', 'MAX'):
                return kernel(args)

            # Special handling for generator functions like NORMAL
            if func_name == 'NORMAL':
                if len(args) != 2:
                    raise ValueError("NORMAL function requires 2 arguments: mean, std_dev")
                # Add the 'size' argument required by the kernel
                return kernel(args[0], args[1], size=self.iterations)

            if func_name == 'LOGNORMAL':
                if len(args) != 2:
                    raise ValueError("LOGNORMAL function requires 2 arguments: mean, sigma")
                return kernel(args[0], args[1], size=self.iterations)

            if func_name == 'POWER':
                if len(args) != 2:
                    raise ValueError("POWER function requires 2 arguments: base, exponent")
                return kernel(args[0], args[1])

            # Note: This simple version assumes functions take one array argument (like SUM)
            return kernel(args[0])

        else:
            # Handle the case where the root of the tree is the operation from parsing, e.g. ('+', (...), (...))
            if node_type in ('+', '-', '*', '/'):
                op_map = {'+': 'add', '-': 'sub', '*': 'mul', '/': 'div'}
                left_val = self._walk_ast(node[1])
                right_val = self._walk_ast(node[2])
                kernel = KERNEL_LIBRARY[op_map[node_type]]
                return kernel(left_val, right_val)


        raise TypeError(f"Unknown AST node type: {node_type}")

# Example Usage
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    if not is_gpu_available():
        print("❌ Cannot run compiler example without a GPU.")
    else:
        # 1. Sample simulation data (1000 iterations for 3 cells)
        sim_data = {
            "A1": cp.random.rand(1000) * 10,
            "B1": cp.random.rand(1000) * 20,
            "C1": cp.random.rand(1000) * 30,
        }
        
        # 2. Initialize the compiler
        compiler = AstCompiler(simulation_data=sim_data, named_ranges={}, iterations=1000)

        # 3. Formula to execute
        formula = "=A1 * (B1 + C1)"
        
        try:
            # 4. Compile and run
            result_array = compiler.compile_and_run(formula)
            
            print(f"Formula: {formula}")
            print(f"Result (first 5 values): {result_array[:5]}")
            print(f"Result Mean: {cp.mean(result_array)}")
            print(f"Result Shape: {result_array.shape}")

        except Exception as e:
            print(f"An error occurred: {e}")

        # 5. Test IF statement
        formula_if = "=IF(A1 > 5, B1, C1)"
        try:
            result_if = compiler.compile_and_run(formula_if)
            print(f"\nFormula: {formula_if}")
            print(f"Result (first 5 values): {result_if[:5]}")
            print(f"Result Mean: {cp.mean(result_if)}")
        except Exception as e:
            print(f"An error occurred during IF test: {e}")

        # 6. Test AND statement
        formula_and = "=IF(AND(A1 > 5, B1 < 10), C1, A1)"
        try:
            result_and = compiler.compile_and_run(formula_and)
            print(f"\nFormula: {formula_and}")
            print(f"Result (first 5 values): {result_and[:5]}")
            print(f"Result Mean: {cp.mean(result_and)}")
        except Exception as e:
            print(f"An error occurred during AND test: {e}")

        # 7. Test NORMAL function
        formula_normal = "=NORMAL(A1, B1) + C1" # Use other cells as mean and std_dev
        try:
            result_normal = compiler.compile_and_run(formula_normal)
            print(f"\nFormula: {formula_normal}")
            print(f"Result (first 5 values): {result_normal[:5]}")
            print(f"Result Mean: {cp.mean(result_normal)}")
        except Exception as e:
            print(f"An error occurred during NORMAL test: {e}")

        # 8. Test MIN/MAX functions
        formula_minmax = "=MIN(A1, B1, C1) + MAX(A1, B1, C1)"
        try:
            result_minmax = compiler.compile_and_run(formula_minmax)
            print(f"\nFormula: {formula_minmax}")
            print(f"Result (first 5 values): {result_minmax[:5]}")
            print(f"Result Mean: {cp.mean(result_minmax)}")
        except Exception as e:
            print(f"An error occurred during MIN/MAX test: {e}")

        # 9. Test SUMIF function
        formula_sumif = '=SUMIF(A1, ">5", C1)'
        # For this test, range and sum_range are single cells
        # We are summing C1 where A1 > 5
        try:
            result_sumif = compiler.compile_and_run(formula_sumif)
            print(f"\nFormula: {formula_sumif}")
            # The result is a single number, not an array
            print(f"Result: {result_sumif}")
        except Exception as e:
            print(f"An error occurred during SUMIF test: {e}")

        # 10. Test NPV function
        formula_npv = "=NPV(A1/100, B1, C1)" # Use A1 as rate, B1 and C1 as cash flows
        try:
            result_npv = compiler.compile_and_run(formula_npv)
            print(f"\nFormula: {formula_npv}")
            print(f"Result (first 5 values): {result_npv[:5]}")
            print(f"Result Mean: {cp.mean(result_npv)}")
        except Exception as e:
            print(f"An error occurred during NPV test: {e}")

        # 11. Test math functions
        formula_math = "=SIN(A1) + POWER(B1, 2)"
        try:
            result_math = compiler.compile_and_run(formula_math)
            print(f"\nFormula: {formula_math}")
            print(f"Result (first 5 values): {result_math[:5]}")
            print(f"Result Mean: {cp.mean(result_math)}")
        except Exception as e:
            print(f"An error occurred during math function test: {e}")

        # 12. Test Lognormal function
        formula_lognormal = "=LOGNORMAL(A1, B1) + C1"
        try:
            result_lognormal = compiler.compile_and_run(formula_lognormal)
            print(f"\nFormula: {formula_lognormal}")
            print(f"Result (first 5 values): {result_lognormal[:5]}")
            print(f"Result Mean: {cp.mean(result_lognormal)}")
        except Exception as e:
            print(f"An error occurred during Lognormal test: {e}")
